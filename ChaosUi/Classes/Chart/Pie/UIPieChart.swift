//
//  UIPieChart.swift
//  ChaosUi
//
//  Created by Fu Lam Diep on 10.02.21.
//

import UIKit
import ChaosAnimation

@IBDesignable
open class UIPieChart: UIView {

    @objc public enum ValueDisplayType: Int {
        case relative, absolute, both
    }

    // MARK: Data and Delegate

    /// Provides information about the chart data.
    @IBOutlet public weak var dataSource: UIPieChartDataSource?

    /// Provides the delegate of this pie chart
    @IBOutlet public weak var delegate: UIPieChartDelegate?

    /// Provides the list of segments to render. Segment objects are generated by
    /// loading. Segments contain the ground truth data.
    private var segments: [SegmentData] = []

    /// Provides the number of segments contained in the pie chart.
    public var numberOfSegments: Int { return segments.count }

    /// Calculates the total value of all segments contained in this chart.
    public var totalValue: Double { segments.reduce(0.0, { $0 + $1.value }) }

    /// Provides the list of segment values relative to the total value.
    private var relativeValues: [Double] {
        let totalValue = self.totalValue
        return segments.map({ $0.value / totalValue })
    }

    private var startAngles: [CGFloat] {
        var startAngle = self.startAngle
        let fullCircle: CGFloat = .pi * 2.0

        return relativeValues.map({
            let angle = startAngle
            startAngle += CGFloat($0) * fullCircle
            return angle
        })
    }

    private var endAngles: [CGFloat] {
        var startAngle = self.startAngle
        let fullCircle: CGFloat = .pi * 2.0
        return relativeValues.map({
            startAngle += CGFloat($0) * fullCircle
            return startAngle
        })
    }

    private var colors: [UIColor] {
        segments.map({ $0.color })
    }

    // MARK: Appearance Properties

    /// Provides the angle in the chart at which the first segment should start
    @IBInspectable open dynamic var startAngle: CGFloat = 0.0

    /// Indicates whether the segments are clockwise or counter-clockwise oriented.
    @IBInspectable open dynamic var clockwise: Bool = true

    /// Provides the inner radius of the pie chart. Values greater than zero
    /// result in a donut chart.
    @IBInspectable open dynamic var innerRadius: CGFloat = .zero

    /// Provides the thickness of the donut. This value is an implicit value. It
    /// is calculated by the radius and inner radius of the chart. Setting this
    /// value implicitly changes the inner radius.
    open dynamic var donutThickness: CGFloat {
        get { radius - innerRadius }
        set { innerRadius = radius - newValue }
    }

    /// Provides the outer radius of the pie chart.
    public var radius: CGFloat { min(bounds.width, bounds.height) / 2 }

    public var chartCenter: CGPoint { CGPoint(x: bounds.midX, y: bounds.midY) }


    // MARK: Internal Properties

    /// Provides the layer added to the root layer displaying the segments
    private var segmentLayers: [CAPieChartSegmentLayer] = []


    // MARK: Initialisation

    public required init?(coder: NSCoder) {
        super.init(coder: coder)
        prepare()
    }

    public override init(frame: CGRect) {
        super.init(frame: frame)
        prepare()
    }

    private func prepare () {
        let tapGestureRecognizer = UITapGestureRecognizer()
        tapGestureRecognizer.addTarget(self, action: #selector(didTap(_:)))
        addGestureRecognizer(tapGestureRecognizer)
    }


    // MARK: Lifecycle

    open override func layoutSubviews() {
        super.layoutSubviews()

        let frame = bounds
        let center = chartCenter
        let radius = self.radius

        segmentLayers.forEach({
            $0.frame = frame
            $0.center = center
            $0.radius = radius
        })
    }


    // MARK: Data Control

    /// Sets up the objects for the data at given index from the data source.
    /// - Parameter index: The index of the corresponding segment
    /// - Parameter dataSource: The data source from which to fetch data
    private func setupSegment (for index: Int, in dataSource: UIPieChartDataSource) {
        let absoluteValue = dataSource.pieChart(self, valueForSegmentAt: index)

        if absoluteValue < 0.0 {
            fatalError("Value for segment at index \(index) may not be negative.")
        }

        let segment = SegmentData()
        segment.title = dataSource.pieChart?(self, titleForSegmentAt: index)
        segment.value = absoluteValue
        segment.color = dataSource.pieChart(self, colorForSegmentAt: index)
        segments.insert(segment, at: index)

        let layer = CAPieChartSegmentLayer()
        layer.center = self.chartCenter
        layer.clockwise = self.clockwise
        layer.innerRadius = self.innerRadius
        layer.radius = self.radius
        self.layer.insertSublayer(layer, at: UInt32(index))
        self.segmentLayers.insert(layer, at: index)
    }

    /// Reloads the data from data source and invokes the view to draw the
    /// segments. Call this function after setting the data source or when the
    /// data source has changed.
    public func reloadData () {
        segmentLayers.forEach({ $0.removeFromSuperlayer() })
        segments = []
        segmentLayers = []

        guard let dataSource = dataSource else {
            setNeedsLayout()
            return
        }

        (0..<dataSource.numberOfSegments(self)).forEach({ self.setupSegment(for: $0, in: dataSource) })

        if totalValue == 0.0 {
            fatalError("The total value of all segments must be greater than 0.")
        }

        reloadSegmentLayers(animated: false)
    }

    /// Reloads the segment data for the given index from given data source.
    /// - Parameter index: The index for which to reload the data
    /// - Parameter dataSource: The data source from which to fetch the data
    private func reloadSegmentData (at index: Int, from dataSource: UIPieChartDataSource) {
        let segment = segments[index]
        segment.title = dataSource.pieChart?(self, titleForSegmentAt: index)
        segment.value = dataSource.pieChart(self, valueForSegmentAt: index)
        segment.color = dataSource.pieChart(self, colorForSegmentAt: index)
    }


    // MARK: View Control

    open func reloadSegments (at indices: [Int], animated: Bool) {
        guard let dataSource = dataSource else {
            fatalError("No data source set for pie chart.")
        }

        for index in indices {
            reloadSegmentData(at: index, from: dataSource)
        }

        reloadSegmentLayers(animated: animated)
    }


    open func insertSegment (at indices: [Int], animated: Bool) {
        guard let dataSource = dataSource else {
            fatalError("No data source set for pie chart.")
        }

        let numberOfSegments = dataSource.numberOfSegments(self)
        guard segments.count + indices.count == numberOfSegments else {
            fatalError("The number of existing values (\(segments.count)) " +
                        "plus the number of values to insert " +
                        "(\(indices.count)) must be equal to the number of " +
                        "values in the data source (\(numberOfSegments)).")
        }

        indices.sorted().forEach({
            self.setupSegment(for: $0, in: dataSource)
        })

        reloadSegmentLayers(animated: animated)
    }

    open func deleteSegment (at indices: [Int]) {
        guard let dataSource = dataSource else {
            fatalError("No data source set for pie chart.")
        }

        let numberOfSegments = dataSource.numberOfSegments(self)
        guard segments.count - indices.count == numberOfSegments else {
            fatalError("The number of existing values (\(segments.count)) " +
                        "minus the number of values to remove " +
                        "(\(indices.count)) must be equal to the number of " +
                        "values in the data source (\(numberOfSegments)).")
        }
    }

    private func reloadSegmentLayers (animated: Bool) {
        let startAngles = self.startAngles
        let endAngles = self.endAngles
        let sourceValuesByKeyPathList = segments.enumerated()
            .map({ index, segment -> [String: Any] in
                let layer = self.segmentLayers[index]

                let dict: [String: Any] = [
                    "minAngle": layer.minAngle,
                    "maxAngle": layer.maxAngle,
                    "fillColor": layer.fillColor
                ]

                layer.minAngle = startAngles[index]
                layer.maxAngle = endAngles[index]
                layer.fillColor = segment.color.cgColor

                return dict
            })

        if animated {
            for index in 0..<segmentLayers.count {
                let layer = segmentLayers[index]
                let sourceValuesByKeyPath = sourceValuesByKeyPathList[index]
                let animation = layer.action(forKey: "animation") as? CAAnimationGroup ?? CAAnimationGroup()
                animation.animations = sourceValuesByKeyPath.map({ (key, value) in
                    let animation = CABasicAnimation(keyPath: key)
                    animation.fromValue = value
                    animation.toValue = layer.value(forKey: key)
                    return animation
                })
                animation.duration = 0.25
                animation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)
                animation.fillMode = kCAFillModeForwards
                animation.isRemovedOnCompletion = false
                layer.add(animation, forKey: "animation")
            }
        }
    }

    // MARK: State Methods

    /// Returns the title for the value of the segment at given index.
    public func title (at index: Int) -> String? {
        return segments[index].title
    }

    /// Returns the absolute value of the segment at given index.
    public func value (at index: Int) -> Double {
        return segments[index].value
    }

    /// Returns the relative value of the segment at given index.
    public func relativeValue (at index: Int) -> Double {
        return segments[index].value / totalValue
    }

    /// Returns the relative value of the segment at given index.
    public func color (at index: Int) -> UIColor {
        return segments[index].color
    }

    public func startAngle (at index: Int) -> CGFloat {
        CGFloat((0..<index).reduce(0.0, { $0 + self.relativeValue(at: $1) })) * .pi * 2.0
    }

    public func endAngle (at index: Int) -> CGFloat {
        startAngle(at: index) + CGFloat(relativeValue(at: index)) * .pi * 2.0
    }


    // MARK: Interaction

    @objc private func didTap (_ tapGesutreRecognizer: UITapGestureRecognizer) {
        let point = tapGesutreRecognizer.location(in: self)
        guard point.distance(to: chartCenter) <= radius else { return }
    }
}

